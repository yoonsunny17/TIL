> Algorithm

* 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법

* 알고리즘 표현 방법 두가지
  * **의사코드(Pseudocode)** &  순서도

* 무엇이 좋은 알고리즘인가?
  * 정확성 :star:
  * 작업량
  * 메모리 사용량
  * 단순성: 슈도코드가 단순할수록 어렵긴 해..
  * 최적성

* 알고리즘의 성능
  * 알고리즘의 작업량을 표현할 때 시간복잡도로 표현함
  * 시간 복잡도(Time Complexity) : 연산의 횟수 :star:
    * => 빅-오 표기법(Big-Oh Notation)



> 배열

* 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조
* 다수의 변수로는 하기 힘든 작업을 배열을 활용하여 쉽게 할 수 있다



> 1차원 배열

* `arr = list()` `arr = []` `arr=[1, 2, 3]` `arr=[0] * 10` 
* 크기를 미리 정해놓고 배열을 사용하는 것이 시간적으로 효율적일 때가 있음!
* `arr[0] = 10; //'배열 arr의 0번 원소에 10을 저장해라'` 



> 정렬

* 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순) or 반대의 순서(내림차순) 으로 재배열하는 것
* 대표적인 정렬 방식
  * 버블 정렬(bubble sort)
  * 카운팅 정렬(counting sort)
  * 선택 정렬(selection sort) 
  * 퀵 정렬(quick sort)
  * 삽입 정렬(insertion sort)
  * 병합 정렬(merge sort)

* **당분간 알고리즘 공부할 때 sort(), .sorted 내장함수 금지** => 월말, 과목평가때도 그럴듯..ㅠ

> 버블정렬(Bubble sort)

* 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식

* 선택정렬과 헷갈리지 말 것!!!!

* 정렬 과정

  * 첫번째 원소부터 인접한 원소끼리 계속 자리를 교환하며 맨 마지막 자리까지 이동한다
  * 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다
  * 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블정렬이라 한다

* 시간 복잡도: O(n^2)

* 오름차순 버블정렬

  ```python
  lst = [55, 7, 78, 12, 42]
  
  for i in range(len(lst)-1, 0, -1):
      for j in range(0, i):
          if lst[j] > lst[j+1]:
              lst[j], lst[j+1] = lst[j+1], lst[j]
  
  print(lst) #=> [7, 12, 42, 55, 78]
  ```



> Debugging

* 원하는 line을 찍어주면, 그 줄을 실행하기 전에 잠깐 멈춰줄래? 를 요청하는 의미
  * debugger를 보면 내가 선택한 코드 상단의 코드 라인들에 어떤 값들이 들어갔는지 중간 check가 가능함



> 카운팅 정렬 (Counting sort)

* 중복 요소 개수 세는 방법) data에서 각 항목들의 발생 횟수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 counts에 저장한다.

* 누적 개수 세는 방법) 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 counts의 원소를 조정한다

* 누적 개수 정보를 통해 원소 정렬하는 방법) temp 빈 리스트 사용, 원래 리스트를 역으로 추적하면서 해당 원소에 해당하는 count의 요소를 idx로 하는 temp공간에 숫자 넣고, count 수 - 1 



> 효율 비교

|    알고리즘     | 평균 수행시간 | 최악 수행시간 | 알고리즘 기법 |             비고              |
| :-------------: | :-----------: | :-----------: | :-----------: | :---------------------------: |
| 버블 정렬:star: |    O(n^2)     |    O(n^2)     |  비교와 교환  |      코딩이 가장 손쉽다       |
|   카운팅 정렬   |    O(n+k)     |    O(n+k)     |  비교환 방식  | n이 비교적 작을 때만 가능하다 |
|    선택 정렬    |               |               |               |                               |
|     퀵 정렬     |               |               |               |                               |
|    삽입 정렬    |               |               |               |                               |
|    병합 정렬    |               |               |               |                               |

